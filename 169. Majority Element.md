![GitHub Logo](/image/169.1.png)

没什么悬念的想到了用map,但是要注意只有一个元素的情况，如果nums={1}, 那么n/2=0, 所以应该返回元素1

```java
class Solution {
    public int majorityElement(int[] nums) {
        if (nums.length==1) return nums[0];
        Map map = new HashMap();
        for (int i=0;i<nums.length;i++)
        {
            if (map.get(nums[i])==null)
                map.put(nums[i],1);
            else
            {
                int num = (int)map.get(nums[i]);
                if (num+1>(nums.length/2)) return nums[i];
                map.put(nums[i], num+1);
            }            
        }
        return -1;
    }
}
```

用map的话效率很低，这可能是因为map在查找时效率不高的原因吧，因为map是数组加linkedlist+红黑树实现的，查找的时候需要遍历整个hash节点，如果hash节点比较长的话，效率不高

![GitHub Logo](/image/169.png)

另一种做法是对数组排序先，因为要查找一个元素个数超过数组长度一半，所以排序后的n/2就是要找的元素
```
class Solution {
    public int majorityElement(int[] nums) {
        if (nums.length==1) return nums[0];
        Arrays.sort(nums);
        return nums[nums.length/2];        
    }
}
```